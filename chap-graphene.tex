\chapter{Graphene.js: Building Reusuable Web Components for Data Visualization}
\label{chap:graphene}

\section{Purpose}

The purpose of this chapter is to introduce Graphene.js \autocite{gu2014graphene}, a framework for creating data-driven visualizations and user interfaces, and focuses mainly on how Graphene is used to overcome technical challenges for building interactive web applications.
In addition, the Graphene.js approach to data visualization is contrasted to currently established JavaScript drawing libraries.
Graphene is the one of the key components in the user interfaces of the other applications described in subsequent chapters.

\section{Motivation}

Graphical representations of information are valuable for presenting complex information quickly and clearly. \autocite{newsom2007public, smiciklas2012power, tufte1983visual}
They can vastly improve comprehension by using graphics to enhance the human visual systemâ€™s ability to see patterns and trends. \autocite{heer2010tour, sears2007human}

Modeling standards and open source software packages, as reviewed in  Software in chapter~\ref{chap:background}, have been a boon to the biomedical research community.
While there are a wide variety of powerful tools that have been developed over the years, there is a distinct lack of web applications.
One way to get a sense of the current landscape of modeling software is to consider the SBML Software Guide \autocite{sbml2014software}, which has conveniently organized and characterized publicized SBML compatible software.
Of the 96 closed-source software packages listed in the Software Guide, only 24 contain any type of web based features and only one can be considered an HTML5 web application \autocite{olivier2004web}.
Of the 166 free and open source softwares listed, just 37 contain any web capabilities, and none of which are an HTML5 application.
\subsection{Challenges in building complex web applications}
There are several obstacles to building biomodeling web applications, which may explain the absence of web applications in the biomodeling domain.
Scientific libraries that most biomodeling software depends on have been intended for desktop use, which can also be used server-side in a web application, but requires additional expertise.
Furthermore, designing and implementing complex graphical user interfaces (GUIs) on the web is a nontrivial engineering challenge.
As discussed in section~\ref{sec:html5} HTML was originally designed as a markup language for communicating static pages that contain text and limited amounts of media, while using CSS for styling.
The rise of JavaScript support within browsers allowed web pages to evolve more interactive behaviors, leading eventually to the web applications of today.
However, JavaScript was originally intended for simple scripts which manipulate the DOM, and this legacy has lead to challenges in scaling increasingly complex JavaScript applications.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth,natwidth=610,natheight=642]{images/jquery-marketshare.png}
  \caption{Market share client-side JavaScript libraries as of May 2014. \autocite{w3techs2014javascript}}
  \label{fig:jquery-marketshare}
\end{figure}

By far, the most popular client-side JavaScript library is jQuery. \autocite{w3techs2014javascript}
Of the 59.2\% of websites that contain JavaScript, JQuery is present in 93.8\% of them (Figure~\ref{fig:jquery-marketshare}).
In web applications that primarily rely on JQuery, the most common design pattern is to treat the DOM as the data model (DOMAM).
In DOMAM, controller logic acts on the DOM directly, creating, updating, and deleting DOM components when the application data model changes.
DOMAM style applications are easy to implement for small applications, but as they grow larger and more complex, the lack of separating the model and view leads to difficulties for software maintenance and continued development.
Section~\ref{sec:declarative-vs-imperative} provides more description and examples on the weaknesses of the DOMAM pattern, as it is perhaps easier to understand when compared to the alternative solution.

\subsection{Most existing drawing libraries follow the jQuery DOM manipulation pattern and are less suited for complex and customizable visualizations}
A key component of GUI for computational systems biology application is in its bio-network graph layout.
In order to reduce duplication of code effort and promote programming best practices, it is desirable to use a software library when solving recurring software problems.
However, most JavaScript drawing libraries encourage the DOMAM pattern or lack customization options.
Being able to customize the visual layout allows for greater design control of an application's UI. 
Better web designs are important because it may increase user engagement and likelihood of revisiting. \autocite{rosen2004website}

\section{Solution}

\subsection{Declarative vs. Imperative: Data-binding over DOM manipulation}
\label{sec:declarative-vs-imperative}

Thus far, the deficiencies in building and scaling web applications using the DOMAM approach have been stated, but what better alternative exists?
Graphene.js is built on top of Angular.js \autocite{google2014angular}, and adopts its design methodology.

Two of the most important components that Graphene uses are DOM scopes and directives (Figure~\ref{Figure:dom-scope}).
A scope can be thought of as a variable namespace that belongs to a section of the DOM.
Child scopes may be attached to child elements, and may inherit references to variables from its parent scope.
The topmost scope is referred to as the root scope, which is may typically bound to the \texttt{<body>} element.

Directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell Graphene to attach a specified behavior to that DOM element or even transform the DOM element and its children. \autocite{google2014angularDirectives, google2014angulardirectives2}
Angular comes with a set of directives, such as \texttt{ng-repeat}, but new ones can also be defined.

\begin{figure}
  \centering
  \includegraphics[width=0.48\textwidth, page=23, trim=0cm 0cm 11cm 0cm, clip=true]{images/Figures.pdf}
  \caption{Scopes and directives in the DOM. Directives define new scopes. Scopes may be configured to inherit values from its parent, or to explicitly bound to a finite number of specified values.}
  \label{Figure:dom-scope}
\end{figure}


Here we will discuss the differences between the DOMAM/jQuery pattern and Graphene approach, which will help explain the design decisions behind Graphene.
Consider this snippet of JavaScript that is used for fetching JSON data from an endpoint:

\begin{lstlisting}[language=JavaScript]
$.ajax({
  url: '/myData.json',
  success: function(data, status) {
    $('ul#log').append('<li>Data Received!</li>');
  }
});
\end{lstlisting}

\texttt{\$.ajax} performs an asynchronous HTTP (Ajax) request, which accepts the location of the data endpoint as \texttt{url} and the callback function as \texttt{success}.
Upon receiving data, we simply append a new \texttt{<li>} into the portion of the DOM that matches the \texttt{'ul\#log'} CSS selector string.
Thus, the view may look something like this:

\begin{lstlisting}[language=html]
<ul class="messages" id="log">
</ul>
\end{lstlisting}

Alternatively, the Graphene approach to accomplishing this same task would look something like this:

\begin{lstlisting}[language=JavaScript]
$http( '/myData.json' ).then( function ( response ) {
  $scope.log.push( { msg: 'Data Received!' } );
});
\end{lstlisting}

With the corresponding view of:

\begin{lstlisting}[language=html]
<ul class="messages">
  <li ng-repeat="entry in log">{{ entry.msg }}</li>
</ul>
\end{lstlisting}

The major difference in the Graphene approach is that the callback function does not manipulate the DOM directly.
The controller is only responsible for updating the data model, \texttt{\$scope.log}.
Thus, the view, with the help of the \texttt{ng-repeat} directive, is reponsible for responding for updating itself to reflect changes in the model.
The controller logic has nothing to do with how the data is actually displayed, and the view will respond to the data regardless of where or how it was changed.
By following Separation of Concerns, a design principle for creating modular programs, the result is simplified development and maintenance.
For example, the view can be swapped out for the following without any need to change the controller logic.

\begin{lstlisting}[language=html]
<div class="messages">
  <div class="alert" ng-repeat="entry in log">
    {{ entry.msg }}
  </div>
</div>
\end{lstlisting}


\subsection{Graphene.js allows for easily customized and reusuable web diagrams}

Graphene uses a Model-View-Controller \autocite{krasner1988description} interface for implementing layouts.
This is a stark contrast to using traditional drawing libraries.
Consider how one must use the drawing API of a well established drawing library, Raphael.js. \autocite{sencha2014raphael} in creating a simple node-edge diagram (Figure~\ref{fig:graphene-simple}).

\begin{figure}
  \centering
  \includegraphics[width=70px,natwidth=610,natheight=642]{images/graphene-simple-70x70.png}
  \caption{A simple node-edge graph diagram.}
  \label{fig:graphene-simple}
\end{figure}

\begin{lstlisting}[language=JavaScript]
// Creates a canvas on the element with id of 'canvas'
var paper = Raphael('#canvas', 100, 100);

// Creates circle node at x = 20, y = 20, with radius 10
var n1 = paper.circle(20, 20, 10);
// Sets the fill attribute of the circle to black
n1.attr("fill", "black");
// Sets the stroke attribute of the circle to blue
n1.attr("stroke", "blue");

// Creates circle node at x = 50, y = 50, with radius 10
var n2 = paper.circle(50, 50, 10);
// Sets the fill attribute of the circle to black
n2.attr("fill", "black");
// Sets the stroke attribute of the circle to blue
n2.attr("stroke", "blue");

// Creates a line from n1 to n2
var edge = paper.path("M20 20L50 50")
edge.attr("fill", "black");
edge.attr("stroke", "black");
\end{lstlisting}

In contrast, the below is the Graphene approach for drawing the same diagram. \autocite{gu2014grapheneSimple}

\begin{lstlisting}[language=JavaScript]
// Data Controller
// Array of node objects
$scope.nodes = [{
  id: 'n1',
  x: 20,
  y: 20
}, {
  id: 'n2',
  x: 50,
  y: 50
}];

// Array of edges, each containing references to source and target nodes
$scope.edges = [{
  source: $scope.nodes[0],
  target: $scope.nodes[1]
}];

// Specify which variables to export to the template
$scope.exports = {
  nodes: $scope.nodes,
  edges: $scope.edges
};
\end{lstlisting}

\begin{lstlisting}[language=html]
<!-- Template -->
<svg width="100" height="100">
  <!-- ng-repeat takes an expression to loop through-->
  <g
    ng-repeat="e in imports.edges"
  >
    <!-- ng-attr-foo takes binds object properties to the DOM element -->
    <line 
      stroke="black"
      stroke-width="3px"
      ng-attr-x1="{{e.source.x}}"
      ng-attr-y1="{{e.source.y}}"
      ng-attr-x2="{{e.target.x}}"
      ng-attr-y2="{{e.target.y}}"
      ></line>
  </g>
  <g 
    ng-repeat="n in imports.nodes"
    ng-attr-transform="translate({{n.x}}, {{n.y}})"
    >
    <circle
      r="10"
      fill="black"
      stroke="blue"
      stroke-width="3px"
    ></circle>
  </g>
</svg>
\end{lstlisting}

The template and controller logic is invoked through the use the \texttt{sg-graphene} directive.

\begin{lstlisting}[language=html]
<sg-graphene template="views/template.html" imports="exports"><sg-graphene>
\end{lstlisting}

Graphene separates the data controller from the view.
Arguably, this format results in code that is more readable, HTML/SVG is used to declaratively define the view.
But perhaps more importantly, separation of concerns is achieved and the view is decoupled from data logic.
Another benefit in the Graphene example is two-way data binding allows the view to be updated when the data changes.
This is a non-trivial task to implement for the Raphael example.
Graphene.js addresses these issues by using a different approach.
Graphene creates interactive diagrams through two-way-binding of the application data model to a customizable SVG template.
Thus, no custom rendering engine is required as it is performed by the browser, and the rich SVG vocabulary (which may be created through a text editor or through a graphical SVG drawing program) may be used to define nearly any type of edge, arrow marker, or Bezier curve.
Graphene templates may also be customized for visualizations beyond node-edge graphs, such as charts and animations.

Cytoscape.js \autocite{cytoscape2014js} is a graph drawing library and a potential choice for network visualization. 
It contains an impressive HTML5 Canvas based rendering engine, but currently lacks the ability to customize the following:

\begin{itemize}
\item Color gradients for nodes
\item Marker ends and node shapes beyond a predefined set
\item Control points for Bezier curves
\item Placement of edge start and end points
\end{itemize}

In addition, since Cytoscape.js produces a canvas drawing and not DOM elements, the graph elements are unable to be used with other JavaScript libraries (for example a popover plugin that acts on each node) nor bound to custom events.
Cytoscape Web \autocite{cytoscape2014web} is a similar library, but is based on Adobe Flash, which limits its utility for cross platform deployment.


\section{Implementation}

\subsection{Data-binding}
Graphene contains one main dependency, Angular.js, which is the underlying engine responsible for data-binding and directive definitions.
Data-binding in Angular is done through a process known as "dirty-checking".
Dirty-checking is performed by a series of watchers, which compares new values to its previous value. \autocite{google2014angularScope}
If a value change is detected, the defined change callback function is fired.

A major component of Graphene, \texttt{sg-graphene}, is a custom directive responsible for binding the layout template to objects defined in the controller.
In addition, Graphene also includes helper functions for determining line intersections points for edge placement, and additional directives for imbuing zooming and click-to-drag behavior.


\begin{figure}
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \includegraphics[width=\textwidth,page=4,trim=0.37cm 3.65cm 15cm 5cm, clip=true]{images/Figures.pdf}
    \caption{Graphene logo, which was created using the Graphene.js}
    \label{Figure:graphene-logo}
  \end{subfigure}
  \begin{subfigure}[t]{.45\textwidth}
    \includegraphics[width=\textwidth,page=4,trim=10cm 0cm 0cm 1cm, clip=true]{images/Figures.pdf}
    \caption{By using two-way data binding through Graphene, graphics can bound to data variables, which is important for interactivity.
      In this example, the "nodeSize" and "hexSize" variables, which can be changed programmatically or bound to other DOM elements, change the hexagonal      grid and vertex sizes independently}
    \label{Figure:graphene-data-binding}
  \end{subfigure}
  \begin{subfigure}[b]{\textwidth}
    \includegraphics[width=\textwidth,page=21,trim=0cm 10cm 4cm 0cm, clip=true]{images/Figures.pdf}
    \caption{Overall architecture for a Graphene web component. The Data Controller parses and prepares input data for binding. 
      The Graphene directive takes exported object references from the Data Controller and allows them to be accessible through the template and Layout C      ontroller.}
    \label{Figure:graphene-diagram}
  \end{subfigure}
  \caption{Overview of Graphene.}
  \label{Figure:graphene}
\end{figure}

\subsection{External JavaScript libraries can add functionality}
Graphene can easily be used augmented with external JavaScript libraries.
One example is the use of D3.js \autocite{bostock2014d3} for its force-directed layout algorithm.
D3 uses the Barnes-Hut algorithm for simulating the force system. \autocite{bostock2011d3}

\begin{lstlisting}[language=JavaScript]
// Initalize force coordinate system
var force = d3.layout.force()
  .size([$scope.width || 800, $scope.height || 800]);

// Bind links and nodes to the new force system
force
  .nodes($scope.nodes)
  .links($scope.links)
  .on('tick', function() {
    // Bind callback function that runs on every 'tick' of force layout
    if ($scope.height && $scope.width) {
      // this ensures that no nodes ever leave the outermost edges
      // of the force coordinate system
      _.each($scope.nodes, function(n) {
        n.x = Math.max(n.width, Math.min($scope.width -
          n.width, n.x));
        n.y = Math.max(n.height, Math.min($scope.height -
          n.height, n.y));
      });
    }
    // Triggers a digest cycle so view can update with new node positions
    $scope.$digest();
  })
  // Begin force simulation
  .start();
\end{lstlisting}

\subsection{Ease of integration into other applications}

Graphene was developed with the with open web build tools in order to follow best practices in web development, allow users to easily integrate Graphene within their own codebases, and promote modular design.
Web development build tools used by Graphene consist of: yo \autocite{yeoman2014yo}, grunt \autocite{alman2014grunt}, and bower \autocite{twitter2014bower}.
yo consists of a number of community maintained and developed generators that scaffold out new applications, generate Grunt configurations and pulling in relevant Bower dependencies.
Grunt is a task runner, used to build, preview, test, and deploy projects.
Bower is a dependency management system, so developers no longer have to manually download and manage JavaScript packages.
Thorough documentation and numerous tutorials are available online for users to become familiar with these build tools.

The development of Graphene is version-controlled using git.
Graphene uses semantic versioning, following the \texttt{major.minor.patch} format.
Patch version changes should be completely backwards compatible, minor version changes should be mostly backwards compatible, and major version changes should require review and possible adjustment current implementations.
Versions are labeled with git tags which are pushed to the main repository, which lets users install Graphene easily using the command \texttt{bower install graphene} (specific versions may be installed by appending the version number, for example \texttt{bower install graphene\#1.0.0} for installing version 1.0.0).
For the developers and maintainers of Graphene, new versions can be tested and deployed to GitHub through the command \texttt{grunt dist}.

\section{Future Directions}
The trend of web standards and development was one of the major underlying motivators for the Graphene approach.
Directives and data-binding that is provided Angular.js are actually stepping stones for Native HTML Web Components \autocite{w3c2014components}, HTML Templates \autocite{w3c2014templating}, and ECMAScript 6 \texttt{Object.observe} data-binding \autocite{polymer2014templating}.

Version 1.1.0 of Graphene has already been released and is currently used in production on several projects, which will be described in the subsequent chapters.
While there are no current plans for major releases, bug fixes will be addressed promptly so no downstream project is disrupted.
